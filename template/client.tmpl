package {{ .SnakeCaseName }}

import (
    "fmt"
    "sync"

    "github.com/grpc-ecosystem/grpc-opentracing/go/otgrpc"
    "github.com/lileio/lile"
    opentracing "github.com/opentracing/opentracing-go"
    "google.golang.org/grpc"
)

const serviceName = "{{ .Name }}"

var (
	cm = &sync.Mutex{}
	Client {{ .CamelCaseName }}Client
)

func Get{{ .CamelCaseName }}Client(url string) {{ .CamelCaseName }}Client {
	cm.Lock()
	defer cm.Unlock()

	if Client != nil {
		return Client
	}

	serviceURL := "{{ .SnakeCaseName }}:80"
	if url != "" {
		serviceURL = url
	}

	if lile.GlobalService() != nil && lile.GlobalService().Registery != nil {
		registeryURL, err := lile.GlobalService().Registery.Get("{{ .SnakeCaseName }}")
		if err != nil {
			fmt.Printf("lile: error contacting Registery for service %s. err: %s \n", "{{ .SnakeCaseName }}", err.Error())
		}

		if registeryURL != "" {
			serviceURL = registeryURL
		}
	}

	// We don't need to error here, as this creates a pool and connections
	// will happen later
	conn, _ := grpc.Dial(
		serviceURL,
		grpc.WithInsecure(),
		grpc.WithUnaryInterceptor(
			otgrpc.OpenTracingClientInterceptor(opentracing.GlobalTracer()),
		))

	cli := New{{ .CamelCaseName }}Client(conn)
	Client = cli
	return cli
}
